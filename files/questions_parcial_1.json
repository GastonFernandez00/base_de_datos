[
	{
		"question": "Una relacion uno a muchos en un DER da origen a una nueva tabla",
		"answer": false,
		"explanation": "Una relacion 1:N se implementa añadiendo una clave foranea en la tabla del lado 'muchos', no creando una nueva tabla."
	},
	{
		"question":"En el analisis de las formas normales, cada relacion se analiza de manera separada del resto de relaciones",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Un DDL(data definition language) provee un lenguaje para la formulacion de consultas, entre otras cosas",
		"answer":false,
		"explanation": "El DDL se usa para definir y modificar la estructura de la base de datos (CREATE, ALTER, DROP). La formulacion de consultas se realiza con el DQL (Data Query Language), principalmente con el comando SELECT."

	},
	{
		"question":"en un der una interrelacion muchos a muchos genera un nuevo atributo en la tabla mas que tuplas tiene y que es clave foranea hacia la clave principal de la tabla que tiene menos registros",
		"answer":false,
		"explanation": "Una relacion muchos a muchos se resuelve creando una nueva tabla intermedia que contiene claves foraneas a las claves primarias de ambas tablas originales, no añadiendo un atributo a una de las tablas existentes."

	},
	{
		"question":"Una dependencia funcional no trivial es aquella que tiene del lado izquierdo una clave candidata",
		"answer":false,
		"explanation": "Una dependencia funcional no trivial es aquella donde el lado derecho no es un subconjunto del lado izquierdo."

	},
	{
		"question":"Si tengo una relacion de la forma EMPLEADO(Legajo, Nombre, Apellido, Telefono) donde un empleado puede tener mas de un telefono el atributo 'legajo' es la clave principal y el atributo telefono es clave candidata",
		"answer":false,
		"explanation": "Si un empleado puede tener multiples telefonos, la tabla no estaria en 1FN. El atributo 'Telefono' no puede ser clave candidata porque sus valores no serian unicos (un mismo 'Telefono' no identifica univocamente a un empleado si este tiene varios, y un 'Legajo' se repetiria con diferentes telefonos), y no determinaria al resto de atributos."

	},
	{
		"question":"Si una interrelacion uno a muchos tiene un atributo genera un atributo en la tabla del lado del muchos",
		"answer":true,
		"explanation": null

	},
	{
		"question":"Las dependencias funcionales son un caso especial de las dependencias multivaluadas",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Un DDL(data definition language) provee un lenguaje para indicar los atributos de una tabla entre otras cosas",
		"answer":true,
		"explanation":null

	},
	{
		"question":"En un DER una interrelacion uno a uno de tipo 'es un' genera un nuevo campo o conjunto de campos en la tabla que tiene menor cantidad de registros y es una clave foranea que apunta a la clave de la tabla que tiene mayor cantidad de registros",
		"answer":true,
		"explanation":null

	},
	{
		"question":"La dependencia funciona X->Y es trivial si Y es un subconjunto de X (Y Incluido en X)",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Si tengo una relacion de la forma EMPLEADO(LEGAJO, DNI, NOMBRE, APELLIDO, TELEFONO) donde un empleado puede tener mas de un telefono, la clave principal es el conjunto de atributos ('legajo','telefono') y el conjunto ('dni','telefono') es la clave candidata",
		"answer":true,
		"explanation":"solo legajo no alcanza para definir el telefono"

	},
	{
		"question":"las claves candidatas no necesariamente cumplen con la condicion de minimalidad",
		"answer":false,
		"explanation":"La minimalidad es una condicion fundamental y definitoria de una clave candidata."

	},
	{
		"question":"el conjunto de todas las tuplas posibles de una instancia de relacion es el resultado del producto cartesiano de todos los dominios de los atributos de la relacion",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Las dependencias funcionales determinan que algunas tuplas no son validas para el dominio del problema que las define",
		"answer":true,
		"explanation":null

	},
	{
		"question":"las dependencias funcionales junto con las dependencias multivaluadas se utilizan para determinas las claves principales y candidatas",
		"answer":true,
		"explanation":null

	},
	{
		"question":"el dominio de un atributo de una relacion puede ser un conjunto finito",
		"answer":true,
		"explanation":null

	},
	{
		"question":"una clave candidata no cumple con el requisito de minimalidad como una clave principal o primaria",
		"answer":false,
		"explanation": "La minimalidad es una condicion fundamental y definitoria de una clave candidata."

	},
	{
		"question":"el analisis del cumplimiento de las formas normales se realiza por cada esquema de relacion independiente de los otros",
		"answer":true,
		"explanation":null

	},
	{
		"question":"la forma normal Boyce Codd es lo suficientemente generica para detectar todas las anomalias de actualizacion que pueden producirse",
		"answer":false,
		"explanation": "Aunque BCNF es muy estricta y elimina la mayoria de las anomalias basadas en dependencias funcionales, no detecta ni aborda anomalias que surgen de otros tipos de dependencias (como las dependencias de multivalor) o casos donde la descomposicion para BCNF no conserva todas las dependencias funcionales. No es 'todas' las anomalias posibles."

	},
	{
		"question":"las formas normales son de cumplimiento obligatorio para un diseño correcto de una base de datos",
		"answer":false,
		"explanation": "Aunque las formas normales son pautas muy recomendables para reducir redundancia y anomalias, no son de cumplimiento obligatorio."

	},
	{
		"question":"un esquema indeseable no puede ser implementado en un SGBD",
		"answer":false,
		"explanation": "Un SGBD permite la creacion de esquemas que no cumplen con las formas normales o que tienen un diseño deficiente."

	},
	{
		"question":"un DML no es estrictamente un lenguaje de computacion sino una forma de modelar el dominio del problema",
		"answer":false,
		"explanation": "Un DML (Data Manipulation Language) es un lenguaje de computacion (ej. SELECT, INSERT, UPDATE, DELETE) que se utiliza para manipular datos en una base de datos. El modelado del dominio del problema se realiza con herramientas conceptuales y logicas como los Diagramas Entidad-Relacion (DER), no con DML."

	},
	{
		"question":"cada tupla es una instancia de un esquema de relacion",
		"answer":true,
		"explanation":null

	},
	{
		"question":"las dependencias funcionales se definen en base al dominio del problema",
		"answer":true,
		"explanation":null

	},
	{
		"question":"cuando normalizo una relacion lo que hago es dividir la relacion para que cumpla con las formas normales",
		"answer":true,
		"explanation":null

	},
	{
		"question":"una relacion puede tener una o varias dependencias multivaluadas",
		"answer":true,
		"explanation":null

	},
	{
		"question":"implicacion de dependencias funcionales permite descomponer una dependencia funcional en varias para normalizar una relacion",
		"answer":true,
		"explanation":null

	},
	{
		"question":"la operacion de division del algebra relacional me permite determinar si todos los valores clave de una relacion son valor de un campo en otra relacion",
		"answer":null,
		"explanation":null

	},
	{
		"question":"si un esquema esta normalizado significa que no puede ser subdividido sin perdida de informacion",
		"answer":true,
		"explanation":null

	},
	{
		"question":"las claves se deducen a partir de las dependencias funcionales y las multivaluadads",
		"answer":false,
		"explanation": "Las claves candidatas se deducen principalmente a partir de las dependencias funcionales (DFs), que definen que atributos determinan a otros. Las dependencias multivalor (DMV) se utilizan para la normalizacion a 4FN"

	},
	{
		"question":"a todos los atributos de una relacion se les puede definir un dominio",
		"answer":true,
		"explanation":null

	},
	{
		"question":"si una relacion no tiene dependencias funcionales ni de junta, no se le puede definir una clave principal",
		"answer":false,
		"explanation": "Toda relacion en el modelo relacional debe tener una clave principal para garantizar la unicidad de sus tuplas, que es una propiedad fundamental de los conjuntos. Las dependencias funcionales y de union se utilizan para analizar la redundancia y normalizar la relacion, pero no determinan si una clave principal puede ser definida. Si no hay dependencias, la clave principal puede ser el conjunto completo de atributos de la relacion."

	},
	{
		"question":"una clave foranea siempre apunta a una clave de otra relacion",
		"answer":false,
		"explanation":null

	},
	{
		"question":"cuando encontramos un ciclo DER y determinamos que hay informacion redundante da lo mismo eliminar cualquier interrelacion que forma parte del ciclo para eliminar la redundancia",
		"answer":false,
		"explanation": "No, no da lo mismo. Para eliminar la redundancia en un ciclo DER, es crucial identificar cual interrelacion es realmente derivable o inferible a partir de las otras, basandose en las dependencias funcionales y la semantica del negocio."

	},
	{
		"question":"la clausura de F la utilizo para determinar la clave",
		"answer":true,
		"explanation":null

	},
	{
		"question":"si un conjunto de atributos me determina toda la relacion entonces es una clave",
		"answer":true,
		"explanation":null

	},
	{
		"question":"si en una relacion encuentro mas de una clave quiere decir que la relacion esta desnormalizada",
		"answer":false,
		"explanation": "Encontrar mas de una clave candidata en una relacion es normal y no implica desnormalizacion."

	},
	{
		"question":"una dependencia fucional no trivial es la que tiene mas de un atributo del lado izquierdo",
		"answer":false,
		"explanation": "Una dependencia funcional no trivial es aquella donde el lado derecho no es un subconjunto del lado izquierdo."

	},
	{
		"question":"para guardar un arbol jerarquico de datos utilizo una relacion con una FK a si misma",
		"answer":true,
		"explanation":null

	},
	{
		"question":"nunca puedo permitir nulos en los atributos que constituyen una FK",
		"answer":false,
		"explanation":null

	},
	{
		"question":"nunca puedo permitir nulos en los atributos que constituyen una PK",
		"answer":true,
		"explanation":null

	},
	{
		"question":"nunca puedo permitir nulos en los atributos que constituyen una clave candidata",
		"answer":true,
		"explanation":null

	},
	{
		"question":"si una interrelacion uno a muchos en un DER tiene un atributo este se convierte en un atributo de la entidad del lado uno",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Una relacion uno a muchos en un der da origen a una nueva tabla",
		"answer":false,
		"explanation": "Una relacion 1:N se implementa añadiendo una clave foranea en la tabla del lado 'muchos', no creando una nueva tabla."

	},
	{
		"question":"si una relacion cumple con la forma normal 3 necesariamente cumple con la forma normal 2",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Un DDL(data definition language) provee un lenguaje para eliminar un registro entre otras cosas",
		"answer":false,
		"explanation": "El DDL se usa para definir y modificar la estructura de la base de datos (CREATE, ALTER, DROP de objetos completos). La eliminacion de un registro (fila) especifico es una operacion de manipulacion de datos, realizada por el DML con el comando DELETE."

	},
	{
		"question":"en un der una interrelacion uno a muchos genera una nueva tabla con dos campos o conjuntos de campos que son claves foraneas a cada una de las claves de ambas tablas",
		"answer":false,
		"explanation": "Una relacion uno a muchos (1:N) se implementa añadiendo una unica clave foranea en la tabla del lado 'muchos' que referencia a la clave primaria de la tabla del lado 'uno'."

	},
	{
		"question":"una dependencia funcional no trivial es aquella que tiene del lado izquierdo una clave candidata",
		"answer":false,
		"explanation": "Una dependencia funcional no trivial es aquella donde el lado derecho no es un subconjunto del lado izquierdo."

	},
	{
		"question":"si tengo una relacion de la forma EMPLEADO(legajo, nombre, apellido, telefono) donde un empleado puede tener mas de un telefono la clave sera el conjunto ('legajo', 'telefono')",
		"answer":true,
		"explanation":null

	},
	{
		"question":"la inyeccion de sql (sql injection) puede producirse cuando las tablas tienen datos erroneos",
		"answer":false,
		"explanation": "La inyeccion SQL es una vulnerabilidad de seguridad causada por la falta de validacion de la entrada del usuario y la construccion insegura de consultas SQL, permitiendo que codigo malicioso sea ejecutado."

	},
	{
		"question":"la inyeccion de sql (sql injection) puede producirse cuando hay un mal diseño de la base de datos",
		"answer":false,
		"explanation": "La inyeccion SQL es una vulnerabilidad de seguridad causada por la falta de validacion de la entrada del usuario y la construccion insegura de consultas SQL, permitiendo que codigo malicioso sea ejecutado."

	},
	{
		"question":"la inyeccion de sql (sql injection) puede producirse cuando se otorgan privilegios innecesarios a los usuarios",
		"answer":false,
		"explanation": "La inyeccion SQL es una vulnerabilidad de seguridad causada por la falta de validacion de la entrada del usuario y la construccion insegura de consultas SQL, permitiendo que codigo malicioso sea ejecutado."

	},
	{
		"question":"la inyeccion de sql (sql injection) puede producirse cuando no se controlan los ingresos de textos por parte de los usuarios finales",
		"answer":true,
		"explanation":null

	},
	{
		"question":"en un der una interrelacion uno a uno de tipo 'es un' genera un nuevo campo/s en la tabla que tiene mayor cantidad de registros y es una clave foranea que apunta a la clave de una tabla que tiene menor cantidad de registros",
		"answer":false,
		"explanation": "Genera un nuevo campo en la tabla que tiene menor cantidad de registros, no en la que tiene mas. La clave foranea apunta a la clave primaria de la otra tabla."

	},
	{
		"question":"una relacion uno a muchos surge del analisis del dominio del problema",
		"answer":true,
		"explanation":null

	},
	{
		"question":"una dependencia funcional trivial es aquella que tiene del lado izquierdo una clave foranea",
		"answer":false,
		"explanation": "Una dependencia funcional (X -> Y) es trivial si el lado derecho (Y) es un subconjunto del lado izquierdo (X)."

	},
	{
		"question":"una dependencia funcional trivial es aquella que tiene del lado izquierdo una clave candidata",
		"answer":false,
		"explanation": "Una dependencia funcional (X -> Y) es trivial si el lado derecho (Y) es un subconjunto del lado izquierdo (X)."

	},
	{
		"question":"Los gestores de bases de datos relacionales deben proveer un DDL (data definition language) para generar el diccionario de datos",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Los gestores de bases de datos relacionales deben proveer un DDL (data definition language) para poder modificar la estructura de las tablas si lo necesito",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Los gestores de bases de datos relacionales deben proveer un DDL (data definition language) para realizar las operaciones de ingreso de datos",
		"answer":false,
		"explanation": "El DDL (Data Definition Language) se utiliza para definir y modificar la estructura de la base de datos (CREATE, ALTER, DROP). Las operaciones de ingreso de datos (insertar, actualizar, eliminar registros) se realizan con el DML (Data Manipulation Language), especificamente con el comando INSERT."

	},
	{
		"question":"Los gestores de bases de datos relacionales deben proveer un DDL (data definition language) para eliminar registros de una tabla",
		"answer":false,
		"explanation": "El DDL (Data Definition Language) se utiliza para definir y modificar la estructura de la base de datos (CREATE, ALTER, DROP de objetos completos). La eliminacion de registros (filas) especificos de una tabla es una operacion de manipulacion de datos, y se realiza con el DML (Data Manipulation Language) mediante el comando DELETE."

	},
	{
		"question":"Los gestores de bases de datos relacionales deben proveer un DDL (data definition language) para poder implementar el diseño de SGBD",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Si t1[X] = t2[X] no puede haber t1[Y]!=t2[Y]: en las tuplas donde se repitan los valores de X obligatoriamente se deben repetir los valores de Y para que exista dependencia funcional",
		"answer":true,
		"explanation":null

	},
	{
		"question":"Si t1[X] = t2[X] no puede haber t1[Y]!=t2[Y]: que no deben existir valores repetidos de Y para que exista dependencia funcional",
		"answer":false,
		"explanation": "La primera parte de la afirmacion es la definicion de una dependencia funcional X -> Y. La segunda parte es falsa: la dependencia funcional no exige que los valores de Y sean unicos en general; solo que sean unicos para cada valor dado de X."

	},
	{
		"question":"Si t1[X] = t2[X] no puede haber t1[Y]!=t2[Y]: quiere decir que si el valor del atributo X en una tupla es igual al valor de X en otra tupla entonces deben ser siempre distintos valores de Y apra que exista dependencia funcional",
		"answer":false,
		"explanation": "La primera parte ('Si t1[X] = t2[X] no puede haber t1[Y]!=t2[Y]') es la definicion correcta de una dependencia funcional X -> Y. Esto significa que si X es el mismo en dos tuplas, entonces Y *tambien debe ser el mismo* en esas tuplas. La segunda parte de la afirmacion es la interpretacion opuesta e incorrecta: para que exista X -> $ Y, los valores de Y deben ser iguales (no distintos) cuando los valores de X son iguales."

	},
	{
		"question":"Si t1[X] = t2[X] no puede haber t1[Y]!=t2[Y]: que deben existir valores repetidos de X en distintas tuplas para que exista dependencia funcional",
		"answer":false,
		"explanation": "La primera parte ('Si t1[X] = t2[X] no puede haber t1[Y]!=t2[Y]') es la definicion de una dependencia funcional X -> Y. Esto significa que si X es el mismo en dos tuplas, entonces Y *tambieen debe ser el mismo* en esas tuplas. La segunda parte es incorrecta: no es necesario que existan valores repetidos de X para que la dependencia funcional exista; la definicion establece lo que deberia ocurrir si X se repite."

	},
	{
		"question":"Si t1[X] = t2[X] no puede haber t1[Y]!=t2[Y]: quiere decir que el valor del atributo X en una tupla tiene que ser siempre igual al valor de X en cualquier tupla y siempre distintos valores de Y para que exista dependencia funcional",
		"answer":false,
		"explanation": "La primera parte ('Si t1[X] = t2[X] no puede haber t1[Y]!=t2[Y]') es la definicion precisa de una dependencia funcional X -> Y Esto significa que si dos tuplas tienen el mismo valor para X, entonces Y *debe tener el mismo valor* en esas tuplas. La segunda parte es incorrecta: no implica que el valor de X deba ser siempre igual en todas las tuplas (eso convertiria a X en una clave candidata para la relacion entera si es unico, o implicaria que solo hay un valor posible para X). Tampoco significa que Y deba ser siempre distinto; de hecho, para la DF, Y debe ser igual cuando X es igual."

	},
	{
		"question":"una transaccion se define en base al analisis del dominio del problema",
		"answer":true,
		"explanation":null
	},
	{
		"question":"una transaccion se define como un conjunto de operaciones que obligatoriamente deben ser recuperadas por el SGBD",
		"answer":false,
		"explanation": "Una transaccion es una unidad atomica (todo o nada). La propiedad de durabilidad (ACID) asegura que los cambios confirmados persistan y sean recuperables por el SGBD en caso de fallo, pero la definicion de transaccion no es ser recuperada obligatoriamente."
	},
	{
		"question":"una transaccion es parte del diseño de la base de datos",
		"answer":false,
		"explanation": "Una transaccion es un concepto operativo que asegura la integridad de los datos durante la ejecucion de operaciones sobre la base de datos (parte del DML y TCL), no un elemento que se defina en el diseño estructural (DDL) de la misma."
	},
	{
		"question":"una transaccion se define al momento de la operacion y las implementa la aplicacion cliente",
		"answer":true,
		"explanation":null
	},
	{
		"question":"una transaccion se define como un conjunto de operaciones que no pueden fallar",
		"answer":false,
		"explanation": "Una transaccion es un conjunto de operaciones que deben ejecutarse como una unidad atomica (todo o nada). Esto significa que, si alguna operacion falla, todas las operaciones de la transaccion se deshacen (rollback), de modo que la base de datos vuelve a su estado original consistente. No es que no puedan fallar, sino que su fallo se maneja de forma que no afecte la consistencia."
	},
	{
		"question":"La implicacion de las dependencias funcionales permiten identificar un esquema indeseable",
		"answer":true,
		"explanation":null
	},
	{
		"question":"La implicacion de las dependencias funcionales se utiliza para la determinacion de las claves de un esquema de relacion",
		"answer":true,
		"explanation":null
	},
	{
		"question":"La implicacion de las dependencias funcionales se puede determinar usando los axiomas de inferencia",
		"answer":true,
		"explanation":null
	},
	{
		"question":"La implicacion de las dependencias funcionales es la capacidad que tienen las DFs para poder deducir un nuevo conjunto de DFs a partir de un conjunto dado",
		"answer":true,
		"explanation":null
	},
	{
		"question":"La implicacion de las dependencias funcionales requiere que F(implicante) tenga mas de una DF",
		"answer":false,
		"explanation": "La implicacion de dependencias funcionales se refiere a la capacidad de deducir nuevas dependencias a partir de un conjunto dado F de DFs, usando los Axiomas de Armstrong. Este proceso es valido incluso si F contiene solo una unica dependencia funcional. Por ejemplo, de A -> BC (una sola DF en F), podemos implicar A -> B y A -> C."
	},
	{
		"question":"Una clave no puede contener todos los atributos de una relacion",
		"answer":false,
		"explanation": "Una clave candidata (y por ende la clave principal) si puede contener todos los atributos de una relacion. Esto ocurre cuando ninguna combinacion mas pequeña de atributos puede identificar de forma unica las tuplas. En tal caso, el conjunto de todos los atributos de la relacion es la unica clave candidata posible"
	},
	{
		"question":"si un conjunto de atributos determina toda la relacion entonces ese conjunto es clave",
		"answer":false,
		"explanation": "Si un conjunto de atributos determina a toda la relacion, es una superclave, no necesariamente una clave candidata. Para ser una clave candidata, ademas de determinar toda la relacion, debe cumplir la condicion de minimalidad (ningun subconjunto propio puede determinar la relacion). Una superclave no minima no es una clave."
	},
	{
		"question":"las claves candidatas son aquellas que no cumplen con la condicion de minimalidad",
		"answer":false,
		"explanation": "Una clave candidata debe cumplir obligatoriamente con la condicion de minimalidad (ser el conjunto mas pequeño de atributos que identifica una tupla de forma unica)."
	},
	{
		"question":"el conjunto de todos los atributos siempre es clave",
		"answer":false,
		"explanation": "El conjunto de todos los atributos de una relacion es clave solo si cumple con la condicion de minimalidad."
	},
	{
		"question":"el cumpimiento de una forma normal por parte de una relacion es independiente del cumplimiento o no de las FN por otras relaciones vinculadas de la misma base de datos",
		"answer":true,
		"explanation":null
	},
	{
		"question":"Un DDL (data definition language) provee un lenguaje para crear un nuevo schema entre otras cosas",
		"answer":true,
		"explanation":null
	},
	{
		"question":"una interrelacion mucho a muchos genera una nueva tabla con dos atributos que son claves foraneas a cada una de las claves de ambas tablas",
		"answer":true,
		"explanation":null
	},
	{
		"question":"una dependencia funcional no trivial es aquella que tiene del lado izquierdo una clave candidata.",
		"answer":false,
		"explanation": "Una dependencia funcional no trivial es aquella donde el lado derecho no es un subconjunto del lado izquierdo."
	},
	{
		"question":"si tengo una relacion de la forma EMPLEADO(legajo, dni, nombre, apellido, telefono) donde un empleado puede tener mas de un telefono la clave principal es el conjunto de atributos ('legajo','telefono') y el conjunto ('dni','telefono') es clave candidata",
		"answer":true,
		"explanation":null
	},
	{
		"question":"dada la relacion PERSONA(dni,nombrepersona,apellidopersona,dnihijo) donde la persona puede tener mas de un hijo esta relacion cumple con la forma normal 2 y no con la forma normal 3",
		"answer":false,
		"explanation": "La clave primaria es `(dni, dnihijo)`. Los atributos no clave (`nombrepersona`, `apellidopersona`) dependen parcialmente de `dni` (parte de la clave). Esto viola la Segunda Forma Normal (2FN). Al no cumplir 2FN, tampoco cumple 3FN."
	},
	{
		"question":"dada una relacion PERSONA(dni, dnihijodelapersona,profesiondelapersona) donde la persona puede tener mas de un hijo y una profesion. Esta relacion no cumple con la forma normal 2",
		"answer":false,
		"explanation": "La clave primaria de la relacion es `(dni, dnihijodelapersona)`. El atributo no clave `profesiondelapersona` depende funcionalmente solo de `dni` (una parte de la clave primaria). Esto constituye una dependencia parcial, violando la Segunda Forma Normal (2FN)*"
	},
	{
		"question":"tengo una base de datos en mongoDB y una relacion !:n donde se estima tener un N muy grande, conviene: modelar la relacion de forma embebida",
		"answer":false,
		"explanation": "No, no conviene modelar una relacion 1:N con un N muy grande de forma embebida en MongoDB."
	},
	{
		"question":"tengo una base de datos en mongoDB y una relacion !:n donde se estima tener un N muy grande, conviene: modelar como una coleccion separada",
		"answer":true,
		"explanation":null
	},
	{
		"question":"tengo una base de datos en mongoDB y una relacion !:n donde se estima tener un N muy grande, es indistinto de forma embebida o coleccion separada",
		"answer":false,
		"explanation": "No, no es indistinto. Si en MongoDB tienes una relacion 1:N donde N es muy grande, no es conveniente modelarla de forma embebida. Debes usar una coleccion separada y referenciar los documentos."
	},
	{
		"question":"si una interrelacion uno a muchos en un der tiene un atributo este se convierte en un atributo de la tabla del lado uno",
		"answer":false,
		"explanation": "Si una interrelacion 1:N en un DER tiene atributos, estos atributos se convierten en parte de la tabla del **lado 'muchos'**, junto con la clave foranea que apunta al lado 'uno'. No se añaden a la tabla del lado 'uno', ya que un unico registro del lado 'uno' podria estar relacionado con multiples conjuntos de estos atributos de la interrelacion."
	},
	{
		"question":"el cumplimiento de una forma normal por parte de una relacion depende del cumplimiento o no de las FN por otras relaciones vinculadas de la misma base de datos",
		"answer":false,
		"explanation": "El cumplimiento de una forma normal (FN) es una caracteristica intriinseca de una relacion (tabla) individual, basada en sus atributos y dependencias funcionales internas. No depende de si otras tablas vinculadas en la base de datos cumplen o no con sus propias formas normales. Cada relacion se evaluua de forma independiente para su normalizacion."
	},
	{
		"question":"Un DDL (data definition language) provee un lenguaje para la formuilacion de consultas entre otras cosas",
		"answer":false,
		"explanation": "El DDL (Data Definition Language) se usa para definir y modificar la estructura de la base de datos (CREATE, ALTER, DROP). La formulacion de consultas para recuperar datos** es tarea del DQL (Data Query Language), cuyo comando principal es `SELECT`."
	},
	{
		"question":"en un der una interrelacion muchos a muchos genera un atributo en la tabla que mas tuplas tiene y que es clave foranea hacia la clave principal que tiene menos registros",
		"answer":false,
		"explanation": "Una interrelacion muchos a muchos (M:N)** en un DER siempre genera una **nueva tabla intermedia para su implementacion en el modelo relacional. Esta nueva tabla contiene dos o mas claves foraaneas, cada una apuntando a la clave principal de una de las entidades participantes en la relacion M:N. La cantidad de tuplas en las tablas originales no determina donde se coloca la FK, sino la necesidad de una tabla de unioon para resolver la cardinalidad M:N."
	},
	{
		"question":"una dependencia funcional trivial es aquella que tiene del lado izquierdo una clave foranea",
		"answer":false,
		"explanation": "Una dependencia funcional trivial es aquella donde el lado derecho es un subconjunto del lado izquierdo."
	},
	{
		"question":"si tengo una relacion de la forma EMPLEADO(legajo,nombre,apellido,telefono) donde un empleado puede tener mas de un telefono el atributo legajo es la clave principal y el atributo telefono es clave candidata",
		"answer":false,
		"explanation":null
	}
]
